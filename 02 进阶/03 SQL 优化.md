# 插入优化
1. 批量插入，一次性建议 500-1000条
2. 手动事务提交
   ```SQL
   Start transaction;
   insert ....
   insert ....
   insert ....
   commit;
    ```
3. 按主键顺序插入
4. 大批插入数据 使用 load 

# 主键优化
1. 数据组织方式
   InnoDB 中表数据根据主键顺序组织，这种组织方式成为索引组织表
2. 页分裂
   页可以为空，也可以填充一半，或者 100%。
3. 页合并
   当删除一条记录时，实际未删除，只是标记为删除。  
    当删除记录达到 MERG_THRESHOLD (默认页的50%)，发生页合并
4. 主键的设计原则
   * 尽量降低逐渐的长度
   * 插入数据，尽量顺序插入，使用 AUTO_INCREMENT 自增主键
   * 尽量不适用 UUID（因为无序，且长） 当主键 或者其他自然主键，例如身份证
   * 业务修改 避免修改主键值

# 排序优化
1. Using filesort
   通过表的索引或者全表扫描，读取满足条件的数据行，然后在排序缓存区 sort buffer 中完成排序操作，所有不是通过索引直接返货结果的排序都叫 FileSort 排序
2. Using index
   通过有序索引顺序扫描直接返回的有序数据，交 using index ，不需要额外排序，操作效率高
3. 优化
   * 根据排序字段建立合适索引，多字段也遵循最左前缀原则
   * 尽量使用覆盖索引
   * 多字段排序，一个升序一个降序，此时可在联合索引创建时 使用 asc desc
   * 如果不可避免出现 filesort 大量数据排序时，可适当增加排序缓冲区大小 sort_buffer_size (默认256k)
  
# 分组优化
1. 通过索引提高效率
2. 索引满足最左前缀法则

# limit 优化
优化思路：一般分页查询时，通创建覆盖索引提高性能，通过覆盖索引加子查询形式进行优化

# count 优化
InnoDB 需要一行一行计数，优化思路：自己计数
用法：
* count(*) 总记录数 性能最好
* count(主键) 总记录数
* count(字段) 不含 null 的记录数
* count(1) 总记录数

# update 优化
尽量根据主键/索引字段进行数据更新